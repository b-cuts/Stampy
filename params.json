{"name":"Stampy","tagline":"Java implementation of the STOMP 1.2 specification","body":"# Stampy, a Java implementation of the STOMP 1.2 specification\r\n\r\nThis project was built using Java 7 in Eclipse, with Apache Ant & Apache Ivy.  The artifacts produced are Java 5 compatible. The text below is taken from the generated overview html in the Javadocs.  The build produces 6 artifacts:\r\n\r\n* **stampy-core** - the core message classes\r\n* **stampy-client-server** - the structure for building STOMP 1.2 clients and servers using stampy-core\r\n* **stampy-NETTY-client-server-RI** - the NETTY reference implementation of stampy-client-server\r\n* **stampy-MINA-client-server-RI** - the MINA reference implementation of stampy-client-server\r\n* **stampy-examples** - Examples using both the NETTY & MINA RIs\r\n* **stampy-all** - all of the above.\r\n\r\n# 1.0-RELEASE, 18/02/13\r\n\r\nInitial release.  Artifacts are available from the Maven central repository:\r\n\r\n`dependency org=\"asia.stampy\" name=\"$artifact\" rev=\"1.0-RELEASE\"`\r\n\r\n## stampy-examples-$version\r\n\r\nThe Stampy example code demonstrates how to configure Stampy clients and servers to perform customized tasks.\r\n\r\n### Load Test\r\n\r\nThe load test attempts to send a configurable one million ACK messages from the client to the server and requests one million receipts from the server.\r\n\r\n### Log4j Level Changer\r\n\r\nThis example shows how to send a serializable Java object for execution on a server.\r\n\r\n### System\r\n\r\nThis example shows how to configure a STOMP 1.2 compliant client and server and tests for compliancy.\r\n\r\n## stampy-NETTY-client-server-RI-$version\r\n\r\nThis library provides a Netty implementation of the stampy-client-server-$version STOMP 1.2 architecture.\r\n\r\n### Design considerations\r\n\r\n* Compiled for Java 5 compatibility\r\n* Ease of configuration and use\r\n* DI framework-friendly\r\n* Minimal dependencies\r\n* Massively multithreaded, many clients can communicate with a server simultaneously\r\n* Fast (6 microseconds per message during testing)\r\n* Reliable\r\n* Extensible\r\n* Security focused\r\n\r\n### Dependencies\r\n\r\n* `dependency org=\"asia.stampy\" name=\"stampy-core\" rev=\"$version\"`\r\n* `dependency org=\"asia.stampy\" name=\"stampy-client-server\" rev=\"$version\"`\r\n* `dependency org=\"io.netty\" name=\"netty\" rev=\"3.6.2.Final\"`\r\n* `dependency org=\"org.slf4j\" name=\"slf4j-api\" rev=\"1.6.6\"`\r\n* `dependency org=\"commons-lang\" name=\"commons-lang\" rev=\"2.6\"`\r\n* `dependency org=\"commons-codec\" name=\"commons-codec\" rev=\"1.7\"`\r\n\r\n### Client Configuration (from examples)\r\n\r\nWhile easy to programmatically configure a Netty client gateway, it is expected that a DI framework such as Spring or Guice will be used to perform this task.\r\n\r\nThe following code demonstrates all that is necessary to configure a STOMP 1.2 compliant client:\r\n\r\n```java\r\n  public static AbstractStampyMessageGateway initialize() {\r\n    HeartbeatContainer heartbeatContainer = new HeartbeatContainer();\r\n\r\n    ClientNettyMessageGateway gateway = new ClientNettyMessageGateway();\r\n    gateway.setPort(1234);\r\n    gateway.setHost(\"localhost\");\r\n    gateway.setHeartbeat(1000);\r\n\r\n    ClientNettyChannelHandler channelHandler = new ClientNettyChannelHandler();\r\n    channelHandler.setGateway(gateway);\r\n    channelHandler.setHeartbeatContainer(heartbeatContainer);\r\n\r\n    gateway.addMessageListener(new IDontNeedSecurity()); // DON'T DO THIS!!!\r\n    \r\n    gateway.addMessageListener(new ClientMessageValidationListener());\r\n\r\n    NettyConnectedMessageListener cml = new NettyConnectedMessageListener();\r\n    cml.setHeartbeatContainer(heartbeatContainer);\r\n    cml.setGateway(gateway);\r\n    gateway.addMessageListener(cml);\r\n\r\n    NettyDisconnectListenerAndInterceptor disconnect = new NettyDisconnectListenerAndInterceptor();\r\n    disconnect.setCloseOnDisconnectMessage(false);\r\n    gateway.addMessageListener(disconnect);\r\n    gateway.addOutgoingMessageInterceptor(disconnect);\r\n    disconnect.setGateway(gateway);\r\n\r\n    gateway.setHandler(channelHandler);\r\n\r\n    return gateway;\r\n  }\r\n```        \r\n### Server Configuration (from examples)\r\n\r\nWhile easy to programmatically configure a Netty server gateway, it is expected that a DI framework such as Spring or Guice will be used to perform this task.\r\n\r\nThe following code demonstrates all that is necessary to configure a STOMP 1.2 compliant server:\r\n\r\n```java\r\n  public static AbstractStampyMessageGateway initialize() {\r\n    HeartbeatContainer heartbeatContainer = new HeartbeatContainer();\r\n\r\n    ServerNettyMessageGateway gateway = new ServerNettyMessageGateway();\r\n    gateway.setPort(1234);\r\n    gateway.setHeartbeat(1000);\r\n    gateway.setAutoShutdown(true);\r\n\r\n    ServerNettyChannelHandler channelHandler = new ServerNettyChannelHandler();\r\n    channelHandler.setGateway(gateway);\r\n    channelHandler.setHeartbeatContainer(heartbeatContainer);\r\n\r\n    gateway.addMessageListener(new IDontNeedSecurity()); // DON'T DO THIS!!!\r\n    \r\n    gateway.addMessageListener(new ServerMessageValidationListener());\r\n\r\n    gateway.addMessageListener(new VersionListener());\r\n\r\n    NettyLoginMessageListener login = new NettyLoginMessageListener();\r\n    login.setGateway(gateway);\r\n    login.setLoginHandler(new SystemLoginHandler());\r\n    gateway.addMessageListener(login);\r\n\r\n    NettyConnectStateListener connect = new NettyConnectStateListener();\r\n    connect.setGateway(gateway);\r\n    gateway.addMessageListener(connect);\r\n\r\n    NettyHeartbeatListener heartbeat = new NettyHeartbeatListener();\r\n    heartbeat.setHeartbeatContainer(heartbeatContainer);\r\n    heartbeat.setGateway(gateway);\r\n    gateway.addMessageListener(heartbeat);\r\n\r\n    NettyTransactionListener transaction = new NettyTransactionListener();\r\n    transaction.setGateway(gateway);\r\n    gateway.addMessageListener(transaction);\r\n\r\n    SystemAcknowledgementHandler sys = new SystemAcknowledgementHandler();\r\n\r\n    NettyAcknowledgementListenerAndInterceptor acknowledgement = new NettyAcknowledgementListenerAndInterceptor();\r\n    acknowledgement.setHandler(sys);\r\n    acknowledgement.setGateway(gateway);\r\n    acknowledgement.setAckTimeoutMillis(200);\r\n    gateway.addMessageListener(acknowledgement);\r\n    gateway.addOutgoingMessageInterceptor(acknowledgement);\r\n\r\n    NettyReceiptListener receipt = new NettyReceiptListener();\r\n    receipt.setGateway(gateway);\r\n    gateway.addMessageListener(receipt);\r\n\r\n    NettyConnectResponseListener connectResponse = new NettyConnectResponseListener();\r\n    connectResponse.setGateway(gateway);\r\n    gateway.addMessageListener(connectResponse);\r\n\r\n    gateway.setHandler(channelHandler);\r\n\r\n    return gateway;\r\n  }\r\n```\r\n        \r\n## stampy-MINA-client-server-RI-$version\r\n\r\nThis library provides a Mina implementation of the stampy-client-server-$version STOMP 1.2 architecture.\r\n\r\n### Design considerations\r\n\r\n* Compiled for Java 5 compatibility\r\n* Ease of configuration and use\r\n* DI framework-friendly\r\n* Minimal dependencies\r\n* Massively multithreaded, many clients can communicate with a server simultaneously\r\n* Fast (11 microseconds per message during testing)\r\n* Reliable\r\n* Extensible\r\n* Security focused\r\n\r\n### Dependencies\r\n\r\n* `dependency org=\"asia.stampy\" name=\"stampy-core\" rev=\"$version\"`\r\n* `dependency org=\"asia.stampy\" name=\"stampy-client-server\" rev=\"$version\"`\r\n* `dependency org=\"org.apache.mina\" name=\"mina-core\" rev=\"2.0.7\"`\r\n* `dependency org=\"org.slf4j\" name=\"slf4j-api\" rev=\"1.6.6\"`\r\n* `dependency org=\"commons-lang\" name=\"commons-lang\" rev=\"2.6\"`\r\n* `dependency org=\"commons-codec\" name=\"commons-codec\" rev=\"1.7\"`\r\n\r\n### Client Configuration (from examples)\r\n\r\nWhile easy to programmatically configure a Mina client gateway, it is expected that a DI framework such as Spring or Guice will be used to perform this task.\r\n\r\nThe following code demonstrates all that is necessary to configure a STOMP 1.2 compliant client:\r\n\r\n```java\r\n  public static AbstractStampyMessageGateway initialize() {\r\n    HeartbeatContainer heartbeatContainer = new HeartbeatContainer();\r\n\r\n    ClientMinaMessageGateway gateway = new ClientMinaMessageGateway();\r\n    gateway.setPort(1234);\r\n    gateway.setHost(\"localhost\");\r\n    gateway.setHeartbeat(1000);\r\n\r\n    RawClientMinaHandler handler = new RawClientMinaHandler();\r\n    handler.setGateway(gateway);\r\n    handler.setHeartbeatContainer(heartbeatContainer);\r\n\r\n    gateway.addMessageListener(new IDontNeedSecurity()); // DON'T DO THIS!!!\r\n    \r\n    gateway.addMessageListener(new ClientMessageValidationListener());\r\n\r\n    MinaConnectedMessageListener cml = new MinaConnectedMessageListener();\r\n    cml.setHeartbeatContainer(heartbeatContainer);\r\n    cml.setGateway(gateway);\r\n    gateway.addMessageListener(cml);\r\n\r\n    MinaDisconnectListenerAndInterceptor disconnect = new MinaDisconnectListenerAndInterceptor();\r\n    disconnect.setCloseOnDisconnectMessage(false);\r\n    gateway.addMessageListener(disconnect);\r\n    gateway.addOutgoingMessageInterceptor(disconnect);\r\n    disconnect.setGateway(gateway);\r\n\r\n    gateway.setHandler(handler);\r\n\r\n    return gateway;\r\n  }\r\n```\r\n        \r\n### Server Configuration (from examples)\r\n\r\nWhile easy to programmatically configure a Mina server gateway, it is expected that a DI framework such as Spring or Guice will be used to perform this task.\r\n\r\nThe following code demonstrates all that is necessary to configure a STOMP 1.2 compliant server:\r\n\r\n```java\r\n  public static AbstractStampyMessageGateway initialize() {\r\n    HeartbeatContainer heartbeatContainer = new HeartbeatContainer();\r\n\r\n    ServerMinaMessageGateway gateway = new ServerMinaMessageGateway();\r\n    gateway.setPort(1234);\r\n    gateway.setHeartbeat(1000);\r\n    gateway.setAutoShutdown(true);\r\n\r\n    RawServerMinaHandler handler = new RawServerMinaHandler();\r\n    handler.setGateway(gateway);\r\n    handler.setHeartbeatContainer(heartbeatContainer);\r\n\r\n    gateway.addMessageListener(new IDontNeedSecurity()); // DON'T DO THIS!!!\r\n    \r\n    gateway.addMessageListener(new ServerMessageValidationListener());\r\n\r\n    gateway.addMessageListener(new VersionListener());\r\n\r\n    MinaLoginMessageListener login = new MinaLoginMessageListener();\r\n    login.setGateway(gateway);\r\n    login.setLoginHandler(new SystemLoginHandler());\r\n    gateway.addMessageListener(login);\r\n\r\n    MinaConnectStateListener connect = new MinaConnectStateListener();\r\n    connect.setGateway(gateway);\r\n    gateway.addMessageListener(connect);\r\n\r\n    MinaHeartbeatListener heartbeat = new MinaHeartbeatListener();\r\n    heartbeat.setHeartbeatContainer(heartbeatContainer);\r\n    heartbeat.setGateway(gateway);\r\n    gateway.addMessageListener(heartbeat);\r\n\r\n    MinaTransactionListener transaction = new MinaTransactionListener();\r\n    transaction.setGateway(gateway);\r\n    gateway.addMessageListener(transaction);\r\n\r\n    SystemAcknowledgementHandler sys = new SystemAcknowledgementHandler();\r\n\r\n    MinaAcknowledgementListenerAndInterceptor acknowledgement = new MinaAcknowledgementListenerAndInterceptor();\r\n    acknowledgement.setHandler(sys);\r\n    acknowledgement.setGateway(gateway);\r\n    acknowledgement.setAckTimeoutMillis(200);\r\n    gateway.addMessageListener(acknowledgement);\r\n    gateway.addOutgoingMessageInterceptor(acknowledgement);\r\n\r\n    MinaReceiptListener receipt = new MinaReceiptListener();\r\n    receipt.setGateway(gateway);\r\n    gateway.addMessageListener(receipt);\r\n\r\n    MinaConnectResponseListener connectResponse = new MinaConnectResponseListener();\r\n    connectResponse.setGateway(gateway);\r\n    gateway.addMessageListener(connectResponse);\r\n\r\n    gateway.setHandler(handler);\r\n\r\n    return gateway;\r\n  }\r\n```\r\n        \r\n## stampy-client-server-$version\r\n\r\nThis library provides the structure to implement STOMP 1.2 clients and servers using the stampy-core library.\r\n\r\n### Design considerations\r\n\r\n* Compiled for Java 5 compatibility\r\n* Ease of configuration and use\r\n* DI framework-friendly\r\n* Minimal dependencies\r\n* Reliable\r\n* Extensible\r\n* Security focused\r\n\r\n### Dependencies\r\n\r\n* `dependency org=\"asia.stampy\" name=\"stampy-core\" rev=\"$version\"`\r\n* `dependency org=\"org.slf4j\" name=\"slf4j-api\" rev=\"1.6.6\"`\r\n* `dependency org=\"commons-lang\" name=\"commons-lang\" rev=\"2.6\"`\r\n* `dependency org=\"commons-codec\" name=\"commons-codec\" rev=\"1.7\"`\r\n\r\n### Gateways\r\n\r\nA Stampy gateway is the interface between an application and the technology used to create/accept connections from STOMP 1.2 compliant clients and servers. All gateways extend from AbstractStampyMessageGateway. This class contains common methods for all Stampy gateways and defines abstract methods which must be implemented in an implementation.\r\n\r\n### StampyMessageListener\r\n\r\nAll gateways allow the addition of any number of StampyMessageListeners which are invoked when a STOMP 1.2 message has been received. By themselves the gateway implementations are not STOMP 1.2 compliant. Compliancy is obtained by adding implementations of this listener. The stampy-client-server library contains implementations which enforce compliance. Any additional custom functionality is obtained by creating a new implementation & adding it to the gateway ie: intercepting a specific message type and notifying the application to perform some bit of functionality. Note: the order of addition of these listeners is important.\r\n\r\n#### SecurityMessageListener\r\n\r\nAt least one implementation of this interface must be included in the list of message listeners, and one must be first in the list else a security exception is thrown. This is to ensure that any custom implementations implement any necessary security for their platform.\r\n\r\nAdditional security pre-Stampy can be added to the gateway implementations.\r\n\r\n### Interceptors\r\n\r\nAll gateways allow the addition of interceptors which are invoked for outgoing messages. There are two types; a message interceptor and a text interceptor. Message interceptors can be tailored to intercept specific types & messages while text interceptors inspect all strings prior to sending them down the pipe. They can be used for outgoing security but are more useful for capturing the state of messages prior to the send. This state can be used to then evaluate any subsequent messages received.\r\n\r\nThe AbstractDisconnectListenerAndInterceptor and AbstractAcknowledgementListenerAndInterceptor are two classes which make effective use of this functionality.\r\n\r\n### Heartbeats\r\n\r\nA heartbeat container instance is used by the gateway to automatically send heartbeats at the agreed upon rate. Heartbeats are started by the client and server using the AbstractConnectedMessageListener and AbstractHeartbeatListener StampyMessageListeners.\r\n\r\n## stampy-core-$version\r\n\r\nThis library provides class representations of STOMP 1.2 messages and the ability to convert to and from the classes. It can be used with the additional Stampy libraries or it can be used with existing STOMP client or server implementations.\r\n\r\n### Design considerations\r\n\r\n* Compiled for Java 5 compatibility\r\n* Ease of configuration and use\r\n* DI framework-friendly\r\n* Minimal dependencies\r\n* Reliable\r\n* Extensible\r\n\r\n### Dependencies\r\n\r\n* `dependency org=\"org.slf4j\" name=\"slf4j-api\" rev=\"1.6.6\"`\r\n* `dependency org=\"commons-lang\" name=\"commons-lang\" rev=\"2.6\"`\r\n* `dependency org=\"commons-codec\" name=\"commons-codec\" rev=\"1.7\"`\r\n\r\n### Messages\r\n\r\nAll STOMP message classes implement the StampyMessage interface. Message classes typically have at least two constructors, one blank & the other with parameters - the parameterized constructors are all the mandatory header values that must be set for a valid STOMP message. Should any mandatory header information be missing an exception will be thrown when the message's\r\n\r\nvalidate()\r\n\r\nmethod is called. \r\n\r\nEach StampyMessage class has an associated header class which can be obtained by calling the\r\n\r\ngetHeader()\r\n\r\nmethod. The header classes are wrappers around a map which manages the key value pairs. Known key names have their own getter and setter methods; any key value pair can be added to a Stampy message header.\r\nNote: should a header key already exist in the map any subsequent adds for that key will be ignored. This is to enforce the specification: If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as the value of header entry. Subsequent values are only used to maintain a history of state changes of the header and MAY be ignored. To replace an existing key the header's\r\n\r\nremoveHeader(existingKey)\r\n\r\nmethod must be called first.\r\n\r\n### Parsing\r\n\r\nA message parser is included for converting the raw string messages to their associated StampyMessage objects.\r\n\r\n### Message Bodies\r\n\r\nAny STOMP message that has a body can accept a string as the body as well as any Java serializable object. The mime type used by Stampy to represent such serialized objects is\r\n\r\njava/base64\r\n\r\nEncoding to and from Base64 is handled by the message superclasses & the parser, respectively.\r\n\r\nAdditional functionality is described in these JavaDocs. This work is released under the GPL 2.0 license. No warranty of any kind is offered. Stampy Copyright (C) 2013 Burton Alexander.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}